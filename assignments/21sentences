Vocabulary 2
	during iteration, an exception can be used to find which iterator value is causing the code to break
	during branch processing, an exception can give insight as to which branch process is the one that broke
	when exceptions are thrown, pointers given in the exception can lead the programmers focus to find which items broke the code
	if a top level class in a tree throws an exception, any sub-class for that class will likely also throw exceptions
	in a sin function, the most common reason that an exception would be thrown for beginner programers would be leaving out the MathtoRadian()
	if a complex number is required, and the coefficient of i is 0, an exception will be thrown
	if you want to do iteration across multiple branches, you should use different iterator variables so as to not confuse the compiler
	during for loop iteration, the variable i (used to control amount of iterations) can also be used as a pointer for an item in an array or a character in a string
	instead of constructing a tree of classes that each add a value to an array of integers representing the fibonacci sequence, an iterator could be used to automate the process into one function
	to make the star, I used an iterator containing a sin function to create an array of integers that find the points of a star on a circle
	complex numbers should be avoided as values for the iterator variable because the compiler expects an integer value instead
	pointers are useful when trying to find a value form a specific branch process
	branching can be used with iteration to run a function on each leaf of a tree
	a method can be made that takes an int (a) and returns sin(a), this could be used to branch process multiple sin functions of diff values
	a method can be made that converts complex numbers into and out of a double[] format with the first value representing the constant and the second representing the coefficient of i
	each sub function in a tree has a pointer
	a pointer could locate the value of a sin function that had been saved as a double
	a pointer could locate a complex number that had been saved as an double[] with the first value representing the constant and the second representing the coefficient of i
	starting with the sin function, one could construct a tree containing all the other trig functions in terms of sin (eg: cos(x) = sin((pi/2)-x))
	a tree can be used to store complex numbers
	the output of a sin function will never be a complex number

Vocabulary 3
	if a variable called in a function cannot be located in that function, it is searched for in the last function from the stack
	if a variable called in a function cannot be located in the function's scope, the scope of the function that called the original function is searched
	if a variable is not defined within a block, the scope of the outer function / block is scoped in dynamic scoping
	if a var is not defined within one scope dynamic scope searches outer scope while lexical searches the global scope
	if a var is a global var, there is no need to dynamically scope
	the namespace Math can be used to call functions that are not defined within the scope of your project
	if a var cannot be found within the scope of a function, the last function in the stack's scope will be searched
	blocks are not always added to the stack like functions are
	lexical scoping doesn't use the stack, instead it searches the global scope
	global variables can be referenced from anywhere within the stack
	whenever a namespace function is called to the stack, it points to a scope which contains "global" functions that can be called anywhere
	the function scope contains all vars defined within the function similar to how a block scope contains all vars defined within that block
	in lexical scoping, if a var isn't located within a function's scope, it is searched for in the global scope
	a global var can be referenced within any function, even if it is outside of the function's scope
	namespaces such as Math can be used within functions to call functions that are not defined within the function's scope
	in lexical scoping, if a var isn't located within a block's scope, it is searched for in the global scope
	a global var can be referenced within any block, even if it is outside of the block's scope
	namespace functions (eg: Mathsin()) can be called in any block regardless of whether or not the function is defined within the block's scope
	lexical scoping is not needed to find global variables because they can be referenced from anywhere
	lexical scoping is not needed to use namespace functions because they can be referenced from anywhere
	namespaces are similar to global variables in that any variables or functions defined in the namespace can be called/referenced from anywhere

Vocabulary 4
	a constructor is a function that sets the value of the variables contained in a class
	an object is an instance of a class with specific variables (eg: class automobile, object car is class automobile with height 13m)
	an object is an instance of a class with specific attributes
	objects contain attributes that set them apart from objects of the same class (eg: car height is diff than truck height)
	an accessor method used to retrieve the value of a specific attribute of an object
	a modifier method is used to set the value of an attribute in an object
	a constructor takes a class and initializes it into an object, setting the defining attributes
	a constructor is used to make a specific instance of a class (called an object) which has defining attributes
	a constructor is used to set the attributes of a classes instance to make an object of that class
	an object's attributes, set by the constructor, can later be retrieved from the class using an accessor method
	after an object's attributes have been set with a constructor, they can be changed through modifier methods
	instances of a class are called objects
	classes can set attributes but they are usually defined when an object of that class is made
	a static get method is an example of an accessor method regarding classes
	a static set method is an example of a modifier method regarding classes
	each instance of a class has its own attribute values
	accessor methods are used to retrieve the value of an instance's attributes
	modifier methods are used to set the value of an instance's attributes
	attribute values are retrieved using accessor methods
	attribute values are set using modifier methods
	accessor methods get values while modifier methods set them

Vocabulary 5
	expressions can be used to assign values to primitives
	expressions are often used to trigger a conditional statement
	expressions are often used within linear recursion to modify the input in some way
	expressions are often used in tree recursion to modify the input but they get run much more due to the tree recursion
	expressions in a function with a higher order of growth get run more
	in proper data abstraction, only relevant expression results are printed (unless you are debugging)
	primitives are often compared to trigger conditional statements
	primitives are often used to progress a linearly recursive function (given an int, rerun until the int == some value)
	primitives are often used to progress a function using tree recursion and will be printed out many more times than in a linear counterpart
	expressions within a function of higher order of growth affect primitives much more and much more often than functions of a lower order of growth
	only relevant primitives are printed if proper data abstraction is observed
	linear recursion statements can contain conditional statements for more complex manipulations
	tree recursion statements can contain conditional statements to limit the number of outputs (by skipping modification / returning of some values)
	nested conditional statements have a small (negative?) order of growth (nested if statements get run less than their parents)
	conditional statements can be used to only print certain values in accordance to proper data abstraction
	linear recursion doesn't run itself more than once while tree recursion does
	a linear recursion function nested in another function will run more and therefore have a higher order of growth
	when dealing with linear recursion, printing a final value or final list of values is often more aligned with proper data abstraction than printing every returned value
	tree recursion has a higher order of growth than linear recursion when given the same input
	when dealing with tree recursion, printing a final value or final list of values is often more aligned with proper data abstraction than printing every returned value
	for proper data abstraction, it is unlikely that one would print all returned values of a function with a high order of growth

Vocabulary 6
	polymorphism interface							-
	polymorphism base class							-
	polymorphism subclass								-
	polymorphism superclass							-
	polymorphism reference							-
	polymorphism inheritance hierarchy	-
	interface base class								-
	interface subclass									-
	interface superclass								-
	interface reference									-
	interface inheritance hierarchy			-
	base class subclass									-
	base class superclass								-
	base class reference								-
	base class inheritance hierarchy		-
	subclass superclass									-
	subclass reference									-
	subclass inheritance hierarchy			-
	superclass reference								-
	superclass inheritance hierarchy		-
	reference inheritance hierarchy			-

Vocabulary 7
	Invariant
	Representation
	Algorithm
	Compile
	Interpret
	Virtual
	Indirection
Vocabulary 8
	Object method
	class method
	this (keyword)
	implicit (variable)
	explicit (variable)
	edge (graph)
	node (graph)
Vocabulary 9
	graph
	lowest common ancestor
	acyclic graph
	partition (graph)
	leaf (tree (graph))
	root (tree (graph))
	search (tree)
