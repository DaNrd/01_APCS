Vocabulary 2
	exception				- a break in the flow of code, often used to help locate errors
	iterator				- used to repeatedly run a task (eg, incrementing i in a for loop)
	branch					-
	pointer					-
	tree						-
	sine function		-
	complex Number	-
	during iteration, an exception can be used to find which iterator value is causing the code to break
	during branch processing, an exception can give insight as to which branch process is the one that broke
	when exceptions are thrown, pointers given in the exception can lead the programmers focus to find which items broke the code
	if a top level class in a tree throws an exception, any sub-class for that class will likely also throw exceptions
	in a sine function, the most common reason that an exception would be thrown for beginner programers would be leaving out the MathtoRadian()
	if a complex number is required, and the coefficient of i is 0, an exception will be thrown
	if you want to do iteration across multiple branches, you should use different iterator variables so as to not confuse the compiler
	during for loop iteration, the variable i (used to control amount of iterations) can also be used as a pointer for an item in an array or a character in a string
	instead of constructing a tree of classes that each add a value to an array of integers representing the fibonacci sequence, an iterator could be used to automate the process into one function
	to make the star, I used an iterator containing a sin function to create an array of integers that find the points of a star on a circle
	complex numbers should be avoided as values for the iterator variable because the compiler expects an integer value instead
	pointers are useful when trying to find a value form a specific branch process
	branching can be used with iteration to run a function on each leaf of a tree
	a method can be made that takes an int (a) and returns sin(a), this could be used to branch process multiple sin functions of diff values
	a method can be made that converts complex numbers into and out of a double[] format with the first value representing the constant and the second representing the coefficient of i
	each sub function in a tree has a pointer
	a pointer could locate the value of a sin function that had been saved as a double
	a pointer could locate a complex number that had been saved as an double[] with the first value representing the constant and the second representing the coefficient of i
	starting with the sin function, one could construct a tree containing all the other trig functions in terms of sin (eg: cos(x) = sin((pi/2)-x))
	a tree can be used to store complex numbers
	the output of a sin function will never be a complex number

Vocabulary 3
	dynamic scope		-
	stack						-
	function scope	-
	block scope			-
	lexical scope		-
	global variable	-
	namespace				-
	if a variable called in a function cannot be located in that function, it is searched for in the last function from the stack
	if a variable called in a function cannot be located in the function's scope, the scope of the function that called the original function is searched
	if a variable is not defined within a block, the scope of the outer function / block is scoped in dynamic scoping
	if a var is not defined within one scope dynamic scope searches outer scope while lexical searches the global scope
	if a var is a global var, there is no need to dynamically scope
	the namespace Math can be used to call functions that are not defined within the scope of your project
	if a var cannot be found within the scope of a function, the last function in the stack's scope will be searched
	blocks are not always added to the stack like functions are
	lexical scoping doesn't use the stack, instead it searches the global scope
	global variables can be referenced from anywhere within the stack
	whenever a namespace function is called to the stack, it points to a scope which contains "global" functions that can be called anywhere
	the function scope contains all vars defined within the function similar to how a block scope contains all vars defined within that block
	in lexical scoping, if a var isn't located within a function's scope, it is searched for in the global scope
	a global var can be referenced within any function, even if it is outside of the function's scope
	namespaces such as Math can be used within functions to call functions that are not defined within the function's scope
	in lexical scoping, if a var isn't located within a block's scope, it is searched for in the global scope
	a global var can be referenced within any block, even if it is outside of the block's scope
	namespace functions (eg: Math.sin()) can be called in any block regardless of whether or not the function is defined within the block's scope
	lexical scoping is not needed to find global variables because they can be referenced from anywhere
	lexical scoping is not needed to use namespace functions because they can be referenced from anywhere
	namespaces are similar to global variables in that any variables or functions defined in the namespace can be called/referenced from anywhere

Vocabulary 4
	object					-
	constructor			-
	class						-
	instance				-
	attribute				-
	accessor method	-
	modifier method	-
	a constructor is a function that sets the value of the variables contained in a class
	an object is an instance of a class with specific variables (eg: class automobile, object car is class automobile with height 13m)
	an object is an instance of a class with specific attributes
	objects contain attributes that set them apart from objects of the same class (eg: car height is diff than truck height)
	an accessor method used to retrieve the value of a specific attribute of an object
	a modifier method is used to set the value of an attribute in an object
	a constructor takes a class and initializes it into an object, setting the defining attributes
	a constructor is used to make a specific instance of a class (called an object) which has defining attributes
	a constructor is used to set the attributes of a classes instance to make an object of that class
	an object's attributes, set by the constructor, can later be retrieved from the class using an accessor method
	after an object's attributes have been set with a constructor, they can be changed through modifier methods
	instances of a class are called objects
	classes can set attributes but they are usually defined when an object of that class is made
	a static get method is an example of an accessor method regarding classes
	a static set method is an example of a modifier method regarding classes
	each instance of a class has its own attribute values
	accessor methods are used to retrieve the value of an instance's attributes
	modifier methods are used to set the value of an instance's attributes
	attribute values are retrieved using accessor methods
	attribute values are set using modifier methods
	accessor methods get values while modifier methods set them

Vocabulary 5
	expression				-
	primitive					-
	conditional				-
	linear recursion	-
	tree recursion		-
	order of growth		-
	data abstraction	-
	expressions can be used to assign values to primitives
	expressions are often used to trigger a conditional statement
	expressions are often used within linear recursion to modify the input in some way
	expressions are often used in tree recursion to modify the input but they get run much more due to the tree recursion
	expressions in a function with a higher order of growth get run more
	in proper data abstraction, only relevant expression results are printed (unless you are debugging)
	primitives are often compared to trigger conditional statements
	primitives are often used to progress a linearly recursive function (given an int, rerun until the int == some value)
	primitives are often used to progress a function using tree recursion and will be printed out many more times than in a linear counterpart
	expressions within a function of higher order of growth affect primitives much more and much more often than functions of a lower order of growth
	only relevant primitives are printed if proper data abstraction is observed
	linear recursion statements can contain conditional statements for more complex manipulations
	tree recursion statements can contain conditional statements to limit the number of outputs (by skipping modification / returning of some values)
	nested conditional statements have a small (negative?) order of growth (nested if statements get run less than their parents)
	conditional statements can be used to only print certain values in accordance to proper data abstraction
	linear recursion doesn't run itself more than once while tree recursion does
	a linear recursion function nested in another function will run more and therefore have a higher order of growth
	when dealing with linear recursion, printing a final value or final list of values is often more aligned with proper data abstraction than printing every returned value
	tree recursion has a higher order of growth than linear recursion when given the same input
	when dealing with tree recursion, printing a final value or final list of values is often more aligned with proper data abstraction than printing every returned value
	for proper data abstraction, it is unlikely that one would print all returned values of a function with a high order of growth

Vocabulary 6 http://www.artima.com/objectsandjava/webuscript/PolymorphismInterfaces1.html
	polymorphism					- ability to treat an object of any subclass as an object of that subclasses base class (eg: chocolateMilk extends milk (also inherits liquid properties))
	interface							- communication between multiple different objects
	base class						- class that contains subclasses (root of inheritance tree)
	subclass							- class that inherits properties from a base class
	superclass						- class that subclass inherits from
	reference							- a value that allows a computer to access data indirectly
	inheritance hierarchy	- tree style hierarchy with subclasses stemming from superclasses stemming from a base class
	polymorphism interface							- in polymorphism, interfaces are inherited by subclasses from superclasses but unique features can be added to the subclasses
	polymorphism base class							- in polymorphism, extending a base class or a subclass of that base class both results in the features of the base class being extended to the new class
	polymorphism subclass								- in polymorphism, a subclass of a subclass also inherits the properties of the original subclasses superclass
	polymorphism superclass							- in polymorphism, superclasses extend their properties to their respective subclasses
	polymorphism reference							- in polymorphism, if a subclass hides a public instance variable of its superclass then the subclasses of that subclass will not be able to reference that public instance variable
	polymorphism inheritance hierarchy	- in polymorphism, inheritance hierarchy starts with a base class which has subclasses branching off
	interface base class								- any interfaces present in a base class will be inherited through its subclasses
	interface subclass									- interfaces are inherited by subclasses and can be added to in those subclasses without affecting the base class's interfaces
	interface superclass								- interfaces added in a subclass are not accessible by that classes superclass
	interface reference									- if a superclass hides one of it's superclasses public instance variables, any subclasses of that subclass also will not be able to reference that variable
	interface inheritance hierarchy			- interfaces are inherited through the inheritance hierarchy
	base class subclass									- a subclass of a base class inherits all properties of that base class
	base class superclass								- base classes, by definition, have no superclass
	base class reference								- references can be used to access data stored in a base class
	base class inheritance hierarchy		- base classes are the root of the inheritance hierarchy
	subclass superclass									- subclasses inherit properties from their superclasses
	subclass reference									- subclasses can reference data from their superclasses
	subclass inheritance hierarchy			- in inheritance hierarchy, subclasses inherit from their superclasses
	superclass reference								- superclasses cannot reference from their subclasses
	superclass inheritance hierarchy		- superclasses are higher up on the inheritance hierarchy
	reference inheritance hierarchy			- classes further down on the inheritance hierarchy can reference data from their superclasses

Vocabulary 7
	Invariant				-
	Representation	-
	Algorithm				-
	Compile					-
	Interpret				-
	Virtual					-
	Indirection
	Invariant Representation						-
	Invariant Algorithm									-
	Invariant Compile										-
	Invariant Interpret									-
	Invariant Virtual										-
	Invariant Indirection								-
	Representation Algorithm						-
	Representation Compile							-
	Representation Interpret						-
	Representation Virtual							-
	Representation Indirection					-
	Algorithm Compile										-
	Algorithm Interpret									-
	Algorithm Virtual										-
	Algorithm Indirection								-
	Compile Interpret										-
	Compile Virtual											-
	Compile Indirection									-
	Interpret Virtual										-
	Interpret Indirection								-
	Virtual Indirection									-

Vocabulary 8
	object method				- Obj.method
	class method				- method()
	this (keyword)			- specifies local
	implicit						- Object.implicit
	explicit						- Object.function(explicit)
	edge (graph)				- path that connects nodes
	node (graph)				- location in graph where something exists
	Object method class method					- unlike calling a class method, the object must be included in the call statement of an object method
	object method this									- when calling an object method, the "this" keyword references the values of variables from the current object
	object method implicit variable			- implicit variables are used to reference object methods
	object method explicit variable			- explicit variables are used as arguments for object methods
	object method edge (graph)					- an object method could act as an edge to an object by returning that object
	object method node (graph)					- an object method could be considered a sub-node of an object
	class method this										- class methods do not require the "this" keyword because they act the same way for all instances of the class
	class method implicit variable			- class methods can be invoked with implicit parameters as long as they are of type void
	class method explicit variable			- class methods often are invoked with explicit parameters which are then used in some way by the method
	class method edge (graph)						- class methods can act as an edge by creating new object instances
	class method node (graph)						- class methods are sub-nodes of their classes
	this implicit variable							- the this keyword is used to reference an implicit parameter such as the object calling a method
	this explicit variable							- the this keyword is not used to reference explicit parameters
	this edge (graph)										- the this keyword acts as an edge to the current object
	this node (graph)										- the this keyword connects the node representing the current method to the node representing the current object
	implicit variable explicit variable - implicit parameters are determined based on the languages syntax while explicit parameters are given by the programmer
	implicit variable edge (graph)			- implicit parameters can act as edges by linking the active method to the object used to call the method
	implicit variable node (graph)			- implicit parameters can act as nodes in a hierarchy of classes (since they are often objects)
	explicit variable edge (graph)			- explicit parameters can act as edges by passing a value to a method through arguments
	explicit variable node (graph)			- explicit parameters can be thought of as nodes in a hierarchy of variables
	edge (graph) node (graph)						- edges are the paths that connect 2 nodes in a graph

Vocabulary 9
	graph										- multiple nodes with edges connecting them
	lowest common ancestor	- a sub-node for both nodes that contains the fewest accessible nodes
	acyclic graph						- graph with no cycle paths (loops, start at node 'a' and get back to a without going backwards)
	partition								- self-contained subset of a graph
	leaf										- nodes with no sub-nodes
	root										- nodes with sub-nodes
	search									- going through a graph to find a specific node
	graph lowest common ancestor							- in a tree graph, the lowest common ancestor is the shared sub-node with the fewest super-nodes
	graph acyclic graph												- in an acyclic graph, it is not possible to start at a node, follow a path, and return to the same node
	graph partition														- a partition is a self-contained subset of a graph
	graph leaf																- in a tree graph, a leaf is an outermost sub-node that has no sub-nodes of its own
	graph root																- in a tree graph, a root is the highest super-node with no super-nodes of its own
	graph search															- searching is when the computer looks through a graph to find a specific node
	lowest common ancestor acyclic graph			- acyclic graphs have lowest common ancestors because the nodes cannot lead back to themselves meaning there is a linear hierarchy
	lowest common ancestor partition (graph)	- in acyclic graphs, each partition can have their own lowest common ancestor
	lowest common ancestor leaf								- a leaf node is never the lowest common ancestor
	lowest common ancestor root								- the root is often the lowest common ancestor of two or more nodes
	lowest common ancestor search							- the lowest common ancestor of two or more nodes can be found with a search function
	acyclic graph partition										- in an acyclic graph, each partition is acyclic
	acyclic graph leaf												- the outermost nodes of an acyclic graph are known as its leaf nodes
	acyclic graph root												- the lowest common ancestor of a partition in an acyclic graph is known as a root node (there can be multiple)
	acyclic graph search											- acyclic graphs are easier to search because of the lack of looping
	partition leaf														- in an acyclic graph, each partition has its own leaf nodes
	partition root														- in an acyclic graph, each partition has its own root nodes
	partition search													- if you run a search in one partition, it cannot search the other partitions because they are isolated from each other
	leaf root																	- leaf and root nodes are both located on the extremity of a graph
	leaf search																- when starting at the leaf node, a search would likely end at the root node
	root search																- when starting at the root node, a search function can search any of its sub-node groups
